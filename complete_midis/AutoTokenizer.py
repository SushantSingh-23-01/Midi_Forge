import symusic, pretty_midi, re, json, os

class MidiTokenizer:
    """Base Tokenizer Class"""
    def __init__(self, midis_path:str, step_prec:float=0.125) -> None:   
        """
        Args:
            midis_path (str) : Important: Follow the Format -> Main Folder -> Subfolders (genres) -> midis 
            step_prec (float) : midi-step precision.\n
                - 1 bar = 1.0
                - defualt : 1/8th step = 0.125
            Quantize the entire midi in a DAW to this precision.
        """   
        self.get_file_dir(midis_path)
        self.extract_metadata()
        self.step_prec = step_prec
        self.gen_vocab()
        
    def get_file_dir(self, midis_path:str)->list[str]:
        """
        Args:
            midis_path (str): Important: Follow the Format -> Main Folder -> Subfolders (genres) -> midis 
        """
        self.filenames = []
        for path, subdirs, files in os.walk(midis_path):
            for name in files:
                if name.endswith('.mid'):
                    self.filenames.append(os.path.join(path, name))
    
    def extract_metadata(self):
        """Gets Metadata of midifiles. (name, genre, bpm)"""
        self.metadata = []
        for f in self.filenames:
            path = os.path.normpath(f)
            name = os.path.splitext(os.path.basename(path))[0]
            genre = path.split(os.sep)[-2]
            score = symusic.Score(f, ttype=symusic.TimeUnit.second)
            bpm = round(score.tempos[0].qpm, 2)
            self.metadata.append({'name': name, 'genre': genre, 'bpm': round(bpm, 2)})
    
    def get_midi_data(self, midifile:str)->list[str]:   
        """
        Extract data used to tokenize midifile (i.e convert to integers).
        Important terminolgies:\n
            - Step : starting timestamp of current note - starting timestamp of last note\n
            - duration : duration for which current note is being played -> (note end timestamp - note start timestamp)
        Args:
            midifile (str): Single Midifile

        Returns:
            list[str]: list[pitch, step, duration]
        """
        path = os.path.normpath(midifile)
        self.genre = path.split(os.sep)[-2]     
        score = symusic.Score(midifile, ttype=symusic.TimeUnit.second)
        self.bpm = round(score.tempos[0].qpm, 2)
        track = score.tracks[0]
        input_ids = []
        prev_start = 0
        for note in track.notes:
            pitch = self.int_to_char[note.pitch]
            step = note.start * self.bpm / 60 - prev_start
            dur = note.duration * self.bpm / 60
            
            step = self.step_prec * round(step / self.step_prec)
            dur = self.step_prec * round(dur / self.step_prec)

            step = 16.0 if step >= 16.0 else step
            dur = 16.0 if dur >= 16.0 else dur
            input_ids.extend([f'{pitch}', f'S{step}', f'D{dur}'])
            prev_start = note.start * self.bpm / 60
        return input_ids
    
    def gen_vocab(self):
        """
        Generates artificial vocabulary.
        Features:\n
            - Pitch ranging from C-1 to G9
            - Step and duration ranging from 0 (midi-step) to 16 (midi-step) or 4 bars.\n
            - Genres : name of subfolders in main directory.\n
        """
        pitch = [pretty_midi.note_number_to_name(i) for i in range(0,128)]
        step, duration = [], []
        for i in range(0, int(16 / self.step_prec) + 1):
            step.append(f'S{i*self.step_prec}')
            duration.append(f'D{i*self.step_prec}')
        genres = []  
        for f in self.metadata:
            genres.append(f['genre'])
        genres = list(sorted(set(genres)))
        
        self.vocab = pitch + step + duration + genres
        self.char_to_int = {s:i for i, s in enumerate(self.vocab)}
        self.int_to_char = {i:s for i, s in enumerate(self.vocab)}
        self.vocab_size = len(self.vocab)
    
    def tokenize(self, midifile:str)->list[int]:
        """
        Convert midifile to token_ids (integers) so it can be used as inputs to model.
        Args:
            midifile (str): path to midifile.

        Returns:
            list[int]: token_ids
        """
        input_ids = self.get_midi_data(midifile)
        token_ids = [self.char_to_int[i] for i in input_ids]
        return token_ids
    
    def detokenize(self, token_ids:list[int])->list[str]:
        """
        Converts token_ids (integers generated by a model) back to data which can be saved to midi.
        Args:
            token_ids (list[int]): 

        Returns:
            list[str]: list[pitch, step, duration]
        """  
        return [self.int_to_char[i] for i in token_ids]

    def save_midifile(self, decoded_ids: list[str], tempo: int | float) -> None:
        """
        Saves decoded data after decoding ids generated by model to midi file. 
        Args:
            decoded_ids (list[str]): decoded token ids.
            tempo (int | float): beats per minute
        """
        midifile = pretty_midi.PrettyMIDI(initial_tempo=tempo)
        instrument = pretty_midi.Instrument(program=0)
        previous_start = 0
        for i in range(0, len(decoded_ids)-3, 3):
            pitch = pretty_midi.note_name_to_number(decoded_ids[i])
            start = float(re.sub(r'[^\d\.]+',' ',decoded_ids[i+1])) * 60 / tempo + previous_start
            end = float(re.sub(r'[^\d\.]+',' ',decoded_ids[i+1])) * 60 / tempo + start
            note = pretty_midi.Note(velocity=100, pitch=pitch, start=start, end=end)
            previous_start = start
            instrument.notes.append(note)
        midifile.instruments.append(instrument)
        midifile.write('midiout.mid')
    
    def view_midis_info(self):
        """Used to get general data for each midifile. Helpful to diagnose any problems in midifile."""  
        self.extract_metadata()
        for i in range(len(self.filenames)):
            print(f'\nName of file :',self.metadata[i]['name'])
            print(f'bpm :', self.metadata[i]['bpm'])
          
    def load_vocab_file(self):
        """Save vocabulary to json file."""
        with open(self.config.vocab_load_path,'r') as f:
            self.int_to_char = json.load(f)  
        self.int_to_char = {int(k):v for k,v in self.int_to_char.items()}
        self.char_to_int = {v:k for k, v in self.int_to_char.items()} 
        self.vocab = list(self.char_to_int.keys())
        self.vocab_size = len(self.vocab)
    
    def save_vocab_file(self):
        """Load vocabulary file from json.
        """
        if self.config.vocab_save_path is not None:
            with open(self.config.vocab_save_path,'w') as outfile:
                json.dump(self.int_to_char, outfile)
            print(f'len of tokenized data: {len(self.tokenize(self.filenames[i]))}')
